<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curso: Bases de Datos II (PL/SQL y Administración Oracle)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://kit.fontawesome.com/a1383796d1.js" crossorigin="anonymous"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* stone-100 */
        }
        .nav-active {
            border-bottom-color: #1a56db; /* blue-700 */
            color: #1a56db;
            font-weight: 600;
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            height: 200px;
            max-height: 250px;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 250px;
            }
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            justify-content: center;
            align-items: center;
            padding: 0.5rem;
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background-color: #fefefe;
            border-radius: 1.5rem;
            padding: 1.5rem; /* Ajuste de padding para móviles */
            max-width: 900px;
            width: 100%;
            height: 95vh; /* Se asegura de que no exceda la altura de la ventana */
            position: relative;
            box-shadow: 0 10px 25px rgba(0,0,0,0.25);
            display: flex;
            flex-direction: column; /* Permite que los elementos hijos se apilen verticalmente */
            animation: modal-fade-in 0.3s ease-out;
            overflow: hidden; /* Evita que el contenido se salga del modal */
        }
        @media (min-width: 768px) {
            .modal-content {
                padding: 2rem;
            }
        }
        @keyframes modal-fade-in {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        .close-button {
            position: absolute;
            top: 1rem;
            right: 1.5rem;
            color: #4b5563; /* gray-600 */
            font-size: 2rem;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s ease-in-out;
        }
        .close-button:hover {
            color: #1f2937; /* gray-800 */
        }
        .presentation-content-wrapper {
            /* Permite el scroll vertical si el contenido es largo */
            overflow-y: auto;
            flex-grow: 1; /* Ocupa todo el espacio vertical disponible */
            min-height: 0; /* NECESARIO para que 'overflow-y: auto' funcione correctamente */
            padding-right: 0.5rem; /* Pequeño padding para el scrollbar */
        }
        .presentation-content-wrapper h2 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1d4ed8; /* blue-700 */
            border-bottom: 2px solid #e5e7eb; /* gray-200 */
            padding-bottom: 0.75rem;
            margin-bottom: 1rem;
            margin-top: 1rem;
        }
        @media (min-width: 768px) {
            .presentation-content-wrapper h2 {
                font-size: 1.75rem;
                margin-bottom: 1.5rem;
                margin-top: 2rem;
            }
        }
        .presentation-content-wrapper h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937; /* gray-800 */
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }
        @media (min-width: 768px) {
            .presentation-content-wrapper h3 {
                font-size: 1.5rem;
                margin-top: 1.5rem;
                margin-bottom: 0.75rem;
            }
        }
        .presentation-content-wrapper h4 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #4b5563; /* gray-600 */
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }
        @media (min-width: 768px) {
            .presentation-content-wrapper h4 {
                font-size: 1.25rem;
                margin-top: 1.25rem;
                margin-bottom: 0.5rem;
            }
        }
        .presentation-content-wrapper p {
            line-height: 1.6;
            margin-bottom: 1rem;
            color: #374151; /* gray-700 */
            font-size: 0.95rem;
        }
        @media (min-width: 768px) {
            .presentation-content-wrapper p {
                font-size: 1rem;
                margin-bottom: 1.25rem;
            }
        }
        .presentation-content-wrapper ul, .presentation-content-wrapper ol {
            padding-left: 1.5rem;
            margin-bottom: 1rem;
            color: #374151;
            font-size: 0.95rem;
        }
        @media (min-width: 768px) {
            .presentation-content-wrapper ul, .presentation-content-wrapper ol {
                font-size: 1rem;
                margin-bottom: 1.25rem;
            }
        }
        .presentation-content-wrapper li {
            margin-bottom: 0.5rem;
        }

        .presentation-content-wrapper pre {
            background-color: #1f2937; /* gray-800 */
            color: #e5e7eb; /* gray-200 */
            padding: 1rem;
            border-radius: 0.75rem;
            font-family: 'Fira Code', 'Courier New', Courier, monospace;
            font-size: 0.85rem;
            line-height: 1.5;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
            overflow-x: auto; /* Permite el scroll horizontal en el código */
        }
        @media (min-width: 768px) {
             .presentation-content-wrapper pre {
                padding: 1.5rem;
                font-size: 0.95rem;
            }
        }
        .presentation-content-wrapper code {
            font-family: 'Fira Code', 'Courier New', Courier, monospace;
            background-color: #e5e7eb; /* gray-200 */
            color: #1f2937; /* gray-800 */
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
            font-size: 0.8rem;
        }
        @media (min-width: 768px) {
            .presentation-content-wrapper code {
                font-size: 0.875rem;
            }
        }

        .presentation-content-wrapper table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1rem;
            display: block; /* Permite que el contenedor de la tabla sea un bloque */
            overflow-x: auto; /* Permite el scroll horizontal en tablas */
        }
        .presentation-content-wrapper th, .presentation-content-wrapper td {
            border: 1px solid #d1d5db;
            padding: 0.75rem;
            text-align: left;
            white-space: nowrap; /* Evita que el texto de las celdas se envuelva */
        }
        .slide-nav-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 1.5rem;
            border-top: 1px solid #d1d5db; /* gray-300 */
            padding-top: 1rem;
            flex-shrink: 0; /* Evita que el contenedor se encoja para que los botones sean siempre visibles */
        }
        @media (min-width: 768px) {
             .slide-nav-container {
                margin-top: 2rem;
                padding-top: 1.5rem;
            }
        }
        .slide-nav-button {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem; /* Padding para móviles */
            border-radius: 9999px;
            font-weight: 600;
            transition: background-color 0.3s, transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            font-size: 0.875rem; /* Tamaño de fuente para móviles */
        }
         @media (min-width: 768px) {
            .slide-nav-button {
                padding: 0.75rem 1.5rem;
                font-size: 1rem;
            }
        }
        .slide-nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px -1px rgba(0, 0, 0, 0.15), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
        }
        .slide-nav-button:disabled {
            background-color: #e5e7eb;
            color: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .expected-output {
            background-color: #f3f4f6; /* gray-100 */
            border-left: 4px solid #1d4ed8; /* blue-700 */
            padding: 1rem;
            margin-top: 1rem;
            border-radius: 0.5rem;
            font-family: 'Fira Code', 'Courier New', Courier, monospace;
            font-size: 0.85rem;
            color: #1f2937;
        }
        /* Nueva clase para las palabras reservadas */
        .plsql-keyword {
            color: #4f85e4;
            font-weight: bold;
        }
		.boton-descarga {
			display: inline-block;
			padding: 12px 24px;
			background-color: #60a5fa; /* blue-500 */
			color: white;
			text-decoration: none;
			border-radius: 8px; /* Bordes más redondeados */
			border: none;
			cursor: pointer;
			transition: background-color 0.3s ease, box-shadow 0.3s ease;
			box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Efecto de resalte */
		}

		.boton-descarga:hover {
			background-color: #f97316; /* orange-500 */
			box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15); /* Sombra un poco más grande al pasar el cursor */
		}

        .whatsapp-button {
            position: fixed;
            bottom: 100px;
            right: 25px;
            z-index: 1000;
        }
        .whatsapp-button a {
            display: inline-block;
            background-color: #25d366;
            color: #fff;
            padding: 15px 20px;
            border-radius: 50px;
            text-decoration: none;
            font-size: 16px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s ease;
        }
        .whatsapp-button a:hover {
            transform: scale(1.05);
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">

        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-blue-800">Bases de Datos II: PL/SQL y Administración Oracle</h1>
            <p class="mt-2 text-lg text-gray-600">Plan de estudios interactivo del curso</p>
        </header>

        <main>
            <section id="overview" class="mb-10">
                 <h2 class="text-2xl font-bold text-center text-gray-700 mb-4">Estructura del Curso</h2>
                 <p class="text-center text-gray-600 max-w-3xl mx-auto mb-6">
                    El curso se divide en tres módulos principales: **PL/SQL**, **Administración (DBA)** y **Proyecto Final**. Este gráfico muestra la distribución de semanas dedicadas a cada área temática.
                </p>
                <div class="chart-container">
                    <canvas id="courseStructureChart"></canvas>
                </div>
            </section>

            <nav id="course-nav" class="flex flex-wrap justify-center border-b-2 border-gray-200 mb-8 space-x-2 sm:space-x-4 md:space-x-8">
                <button data-filter="all" class="nav-item nav-active text-sm sm:text-base py-3 px-2 sm:px-4 border-b-4 border-transparent hover:border-blue-500 hover:text-blue-600 transition-all duration-300">Todo</button>
                <button data-filter="1" class="nav-item text-sm sm:text-base py-3 px-2 sm:px-4 border-b-4 border-transparent hover:border-blue-500 hover:text-blue-600 transition-all duration-300">Módulo 1: PL/SQL</button>
                <button data-filter="2" class="nav-item text-sm sm:text-base py-3 px-2 sm:px-4 border-b-4 border-transparent hover:border-blue-500 hover:text-blue-600 transition-all duration-300">Módulo 2: DBA</button>
                <button data-filter="3" class="nav-item text-sm sm:text-base py-3 px-2 sm:px-4 border-b-4 border-transparent hover:border-blue-500 hover:text-blue-600 transition-all duration-300">Módulo 3: Proyecto</button>
                <button data-filter="bibliography" class="nav-item text-sm sm:text-base py-3 px-2 sm:px-4 border-b-4 border-transparent hover:border-blue-500 hover:text-blue-600 transition-all duration-300">Bibliografía</button>
            </nav>

            <div id="content-area">
                <p id="content-intro" class="text-center text-gray-600 max-w-3xl mx-auto mb-8">
                    Bienvenido al plan de estudios. Utiliza las pestañas de navegación para filtrar los temas por módulo o para consultar la bibliografía recomendada. Haz clic en cualquier tarjeta de semana para ver una presentación detallada de su contenido.
                </p>
                <div id="weeks-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                </div>
                <div id="bibliography-content" class="hidden">
                </div>
            </div>
        </main>

        <footer class="text-center mt-12 pt-6 border-t border-gray-200">
            <p class="text-gray-500">Material del curso generado para la carrera de Ingeniería en Sistemas / Licenciatura en Informática.</p>
        </footer>

    </div>

    <!-- Modal para las presentaciones -->
    <div id="presentationModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2 class="text-xl md:text-2xl font-bold text-blue-800 text-center mb-4" id="presentationTitle"></h2>
            <div id="slideContent" class="presentation-content-wrapper text-gray-800">
                <!-- Contenido de la diapositiva actual -->
            </div>
            <div class="slide-nav-container">
                <button id="prevSlide" class="slide-nav-button bg-blue-600 text-white hover:bg-blue-700">
                    <i class="fas fa-chevron-left"></i> Anterior
                </button>
                <span id="slideCounter" class="text-gray-500 font-semibold text-sm sm:text-base"></span>
                <button id="nextSlide" class="slide-nav-button bg-blue-600 text-white hover:bg-blue-700">
                    Siguiente <i class="fas fa-chevron-right"></i>
                </button>
            </div>
        </div>
    </div>

    <div class="chatbot-container">
        <script src="https://cdn.botpress.cloud/webchat/v3.2/inject.js" defer></script>
        <script src="https://files.bpcontent.cloud/2025/08/15/01/20250815011305-AYOL74QI.js" defer></script>
    </div>

    <!-- Grupo de Whapsapp -->
    <div class="whatsapp-button">
        <a href="https://chat.whatsapp.com/Hio8Fe0LE8d6x7JH6U4ECU" target="_blank">
            WS
        </a>
    </div>

    <script>
        // Datos del curso con contenido expandido para las diapositivas
        const courseData = {
            weeks: [
                {
                    week: 1, module: 1, title: 'Presentación, Repaso de SQL e Introducción a PL/SQL',
                    contents: ['Presentación del curso: objetivos, metodología y evaluación.', 'Repaso de SQL: Sentencias DDL, DML y DQL, JOINs, subconsultas y funciones de agregación.', 'Introducción a PL/SQL: ¿Qué es y por qué se usa?'],
                    activities: ['Resolver ejercicios de SQL básico.', 'Discusión de casos de uso de PL/SQL.'],
                    materials: 'Documentación oficial de Oracle, Oracle PL/SQL Programming cap. 2.',
                    presentation: [
                        {
                            title: 'Bienvenido al Curso',
                            content: `
### Objetivos y Enfoque del Curso
Este curso te sumergirá en dos áreas clave de Oracle:
1.  **PL/SQL (Procedural Language/SQL):** El lenguaje de programación de Oracle para construir lógica de negocio dentro de la base de datos.
2.  **Administración (DBA):** Los principios fundamentales para gestionar, optimizar y asegurar una base de datos Oracle.

El objetivo es que no solo sepas cómo escribir código, sino también cómo garantizar que tu base de datos funcione de manera eficiente y segura.
`
                        },
                        {
                            title: 'Repaso de SQL Esencial',
                            content: `
Antes de empezar con PL/SQL, es fundamental dominar SQL.
* **DQL (Data Query Language):** <span class="plsql-keyword">SELECT</span>. El corazón de SQL.
* **DML (Data Manipulation Language):** <span class="plsql-keyword">INSERT</span>, <span class="plsql-keyword">UPDATE</span>, <span class="plsql-keyword">DELETE</span>. Para modificar datos.
* **DDL (Data Definition Language):** <span class="plsql-keyword">CREATE</span>, <span class="plsql-keyword">ALTER</span>, <span class="plsql-keyword">DROP</span>. Para definir la estructura de la base de datos.

**Ejemplo de una consulta compleja:**
\`\`\`sql
-- Se obtiene el nombre del empleado y el nombre de su departamento
-- para los empleados que ganan más de $50,000.
SELECT
    e.nombre,
    d.nombre_departamento
FROM
    empleados e
JOIN
    departamentos d ON e.departamento_id = d.departamento_id
WHERE
    e.salario > 50000;
\`\`\`
`
                        },
                        {
                            title: 'Introducción a PL/SQL',
                            content: `
### ¿Qué es PL/SQL?
**PL/SQL** es la extensión procedural de SQL en Oracle. Combina sentencias SQL con características de programación como variables, bucles y estructuras condicionales, permitiéndote crear programas completos que se ejecutan directamente en la base de datos.

### Palabras Reservadas en un Bloque PL/SQL
Un bloque PL/SQL usa un conjunto de palabras reservadas para definir su estructura:
* **<span class="plsql-keyword">DECLARE</span>**: Sección opcional para la declaración de variables y constantes.
* **<span class="plsql-keyword">BEGIN</span>**: Sección obligatoria que contiene la lógica principal del programa.
* **<span class="plsql-keyword">EXCEPTION</span>**: Sección opcional para el manejo de errores.
* **<span class="plsql-keyword">END</span>**: Marca el final del bloque.
* **<span class="plsql-keyword">DBMS_OUTPUT.PUT_LINE</span>**: El procedimiento para imprimir información en la consola.
* **<span class="plsql-keyword">/</span>**: El carácter que indica al cliente que ejecute el bloque.
`
                        },
                        {
                            title: 'Primer Bloque Anónimo de PL/SQL',
                            content: `
Un bloque anónimo es la estructura más simple de PL/SQL. No se guarda en la base de datos, solo se ejecuta una vez.
\`\`\`sql
-- Este es un bloque anónimo. No tiene nombre y no se guarda.
DECLARE
  -- 1. DECLARACIÓN DE VARIABLES
  v_saludo VARCHAR2(100);
BEGIN
  -- 2. LÓGICA DEL PROGRAMA
  v_saludo := '¡Hola, Mundo desde PL/SQL!';

  -- Imprime el resultado en la consola del servidor
  DBMS_OUTPUT.PUT_LINE(v_saludo);
END;
/
\`\`\`
**Salida esperada:**
\`\`\`
¡Hola, Mundo desde PL/SQL!
\`\`\`

<a href="https://wilmer155.github.io/Cursos/PL_SQL/Material_Apoyo_Clases_PLSQL.rar" download="Material_Apoyo_Clases_PLSQL.rar" class="boton-descarga">
  Descargar Material Apoyo
</a>
`
                        }
                    ]
                },
                {
                    week: 2, module: 1, title: 'Estructura de Bloque y Elementos Básicos de PL/SQL',
                    contents: ['Estructura de un bloque PL/SQL: DECLARE, BEGIN, EXCEPTION, END.', 'Tipos de datos, variables y constantes.', 'Secuencias: Generación de identificadores únicos.', 'Estructuras de control de flujo: IF-THEN-ELSE, CASE, bucles (LOOP, WHILE, FOR).'],
                    activities: ['Escribir bloques anónimos simples y ejercicios de control de flujo.', 'Crear una secuencia y usarla en una sentencia INSERT.'],
                    materials: 'Oracle PL/SQL Programming cap. 3.',
                    presentation: [
                        {
                            title: 'La Estructura de un Bloque PL/SQL',
                            content: `
Un bloque PL/SQL se compone de tres secciones lógicas, aunque solo una es obligatoria:

* **<span class="plsql-keyword">DECLARE</span> (opcional):** Sección para declarar variables, constantes, cursores y excepciones personalizadas.
* **<span class="plsql-keyword">BEGIN</span> (obligatoria):** Contiene la lógica del programa, las sentencias SQL y las estructuras de control.
* **<span class="plsql-keyword">EXCEPTION</span> (opcional):** Sección para manejar errores específicos que puedan ocurrir durante la ejecución del bloque.
* **<span class="plsql-keyword">END</span>** (obligatoria): Marca el final del bloque.

\`\`\`sql
DECLARE
  -- Declaraciones (variables, constantes)
BEGIN
  -- Lógica (sentencias SQL, control de flujo)
EXCEPTION
  -- Manejo de errores
END;
/
\`\`\`
`
                        },
                        {
                            title: 'Variables y %TYPE',
                            content: `
Puedes usar tipos de datos estándar de Oracle (<span class="plsql-keyword">VARCHAR2</span>, <span class="plsql-keyword">NUMBER</span>, <span class="plsql-keyword">DATE</span>). La mejor práctica es usar el atributo **<span class="plsql-keyword">%TYPE</span>** para declarar variables que coincidan con el tipo de dato de una columna existente. Esto hace tu código más robusto a cambios en el esquema de la tabla.

**Palabras clave en este contexto:**
* **<span class="plsql-keyword">CONSTANT</span>**: Define una variable cuyo valor no puede cambiar.
* **<span class="plsql-keyword">%TYPE</span>**: Un atributo que referencia el tipo de dato de una columna o variable.

\`\`\`sql
DECLARE
  v_salario_empleado empleados.salario%TYPE;
  c_bono CONSTANT NUMBER := 1000;
BEGIN
  v_salario_empleado := 65000;
  DBMS_OUTPUT.PUT_LINE('El salario de un empleado es: ' || v_salario_empleado);
END;
/
\`\`\`
`
                        },
                        {
                            title: 'Secuencias: Generación Automática de Identificadores',
                            content: `
Una **secuencia** es un objeto de la base de datos que genera automáticamente valores numéricos únicos, típicamente usados para claves primarias.

**Palabras clave en este contexto:**
* **<span class="plsql-keyword">CREATE SEQUENCE</span>**: Crea un objeto secuencia.
* **<span class="plsql-keyword">INCREMENT BY</span>**: Especifica el valor para incrementar la secuencia.
* **<span class="plsql-keyword">START WITH</span>**: Define el primer valor que generará la secuencia.
* **<span class="plsql-keyword">NEXTVAL</span>**: Atributo que genera y retorna el siguiente valor de la secuencia.
* **<span class="plsql-keyword">CURRVAL</span>**: Atributo que retorna el valor actual de la secuencia.

**Ejemplo:**
\`\`\`sql
-- Se crea una secuencia llamada SEQ_CLIENTES que inicia en 1 y se incrementa de 1 en 1
CREATE SEQUENCE seq_clientes
  INCREMENT BY 1
  START WITH 1;

-- Para obtener el siguiente valor de la secuencia
SELECT seq_clientes.NEXTVAL FROM DUAL;

-- Para insertar una nueva fila usando la secuencia
INSERT INTO clientes (cliente_id, nombre)
VALUES (seq_clientes.NEXTVAL, 'Carlos Ruiz');
\`\`\`
`
                        },
                        {
                            title: '%ROWTYPE: El Tipo de Dato que Representa una Fila',
                            content: `
El atributo **<span class="plsql-keyword">%ROWTYPE</span>** te permite declarar una variable de tipo registro que puede almacenar una fila completa de una tabla o vista. Esto es muy útil para leer datos de una tabla en una sola operación.

**Palabras clave en este contexto:**
* **<span class="plsql-keyword">%ROWTYPE</span>**: Un atributo que referencia la estructura de una fila completa de una tabla o vista.
* **<span class="plsql-keyword">SELECT ... INTO</span>**: Se usa para cargar los datos de una fila en la variable <span class="plsql-keyword">%ROWTYPE</span>.

\`\`\`sql
DECLARE
  -- Declara una variable que es un registro con la misma estructura que la tabla 'empleados'
  v_empleado empleados%ROWTYPE;
BEGIN
  -- Selecciona una fila completa y la almacena en la variable
  SELECT * INTO v_empleado
  FROM empleados
  WHERE empleado_id = 101;

  -- Se puede acceder a los campos del registro como v_empleado.nombre, v_empleado.salario
  DBMS_OUTPUT.PUT_LINE('Nombre: ' || v_empleado.nombre);
  DBMS_OUTPUT.PUT_LINE('Salario: ' || v_empleado.salario);
END;
/
\`\`\`
**Salida esperada:**
(Asumiendo que el empleado 101 se llama 'Juan Pérez' y tiene un salario de 65,000)
\`\`\`
Nombre: Juan Pérez
Salario: 65000
\`\`\`
`
                        },
                         {
                            title: 'El Tipo de Dato RECORD',
                            content: `
El tipo de dato **<span class="plsql-keyword">RECORD</span>** te permite crear tu propia estructura de datos compuesta. A diferencia de <span class="plsql-keyword">%ROWTYPE</span> que se basa en la estructura de una tabla, <span class="plsql-keyword">RECORD</span> te da el control total para definir los campos que necesitas.

**Palabras clave en este contexto:**
* **<span class="plsql-keyword">TYPE</span>**: Se usa para definir el tipo de dato <span class="plsql-keyword">RECORD</span>.
* **<span class="plsql-keyword">IS RECORD</span>**: Indica que se está creando un registro.
* **<span class="plsql-keyword">END RECORD</span>**: Cierra la definición del registro.

\`\`\`sql
DECLARE
  -- 1. Se define un nuevo tipo de dato RECORD con los campos que necesitamos
  TYPE t_info_empleado IS RECORD (
    nombre_completo  VARCHAR2(100),
    salario_anual    NUMBER
  );

  -- 2. Se declara una variable de ese nuevo tipo
  v_info_emp t_info_empleado;
BEGIN
  -- Se asignan valores a los campos individuales del registro
  SELECT nombre, salario * 12
  INTO v_info_emp.nombre_completo, v_info_emp.salario_anual
  FROM empleados
  WHERE empleado_id = 101;

  DBMS_OUTPUT.PUT_LINE('Nombre Completo: ' || v_info_emp.nombre_completo);
  DBMS_OUTPUT.PUT_LINE('Salario Anual: ' || v_info_emp.salario_anual);
END;
/
\`\`\`
`
                        },
                        {
                            title: 'Estructuras Condicionales (`IF`, `CASE`)',
                            content: `
Estas estructuras te permiten controlar el flujo de ejecución de tu código basándose en condiciones.

**Palabras clave en este contexto:**
* **<span class="plsql-keyword">IF</span>**: Comienza una sentencia condicional.
* **<span class="plsql-keyword">THEN</span>**: Define el bloque de código que se ejecuta si la condición de <span class="plsql-keyword">IF</span> es verdadera.
* **<span class="plsql-keyword">ELSIF</span>**: Define una condición alternativa si la primera es falsa.
* **<span class="plsql-keyword">ELSE</span>**: Define el bloque de código por defecto si ninguna de las condiciones anteriores se cumple.
* **<span class="plsql-keyword">CASE</span>**: Una alternativa a <span class="plsql-keyword">IF</span> para múltiples comparaciones sobre una misma expresión.
* **<span class="plsql-keyword">END IF</span>**: Marca el final de la estructura condicional.

**Ejemplo de <span class="plsql-keyword">IF-THEN-ELSIF-ELSE</span>:**
\`\`\`sql
DECLARE
  v_calificacion NUMBER := 85;
BEGIN
  IF v_calificacion >= 90 THEN
    DBMS_OUTPUT.PUT_LINE('Calificación: A');
  ELSIF v_calificacion >= 80 THEN
    DBMS_OUTPUT.PUT_LINE('Calificación: B');
  ELSE
    DBMS_OUTPUT.PUT_LINE('Calificación: C o menor');
  END IF;
END;
/
\`\`\`
`
                        },
                        {
                            title: 'Bucles (`LOOP`, `WHILE`, `FOR`)',
                            content: `
Los bucles se usan para ejecutar repetidamente un bloque de código.

**Palabras clave en este contexto:**
* **<span class="plsql-keyword">LOOP</span>**: Inicia un bucle simple.
* **<span class="plsql-keyword">WHILE</span>**: Inicia un bucle que se ejecuta mientras una condición es verdadera.
* **<span class="plsql-keyword">FOR</span>**: Inicia un bucle con un contador.
* **<span class="plsql-keyword">IN</span>**: Usado en bucles <span class="plsql-keyword">FOR</span> para especificar el rango.
* **<span class="plsql-keyword">EXIT WHEN</span>**: Causa una salida inmediata de un bucle.

**Ejemplo de <span class="plsql-keyword">FOR LOOP</span>:**
\`\`\`sql
BEGIN
  FOR i IN 1..3 LOOP
    DBMS_OUTPUT.PUT_LINE('Iteración: ' || i);
  END LOOP;
END;
/
\`\`\`
**Salida esperada:**
\`\`\`
Iteración: 1
Iteración: 2
Iteración: 3
\`\`\`
`
                        }
                    ]
                },
                {
                    week: 3, module: 1, title: 'Cursores y Procedimientos Almacenados',
                    contents: ['Cursores: Concepto de cursor, tipos (implícito y explícito).', 'Uso de cursores explícitos: OPEN, FETCH, CLOSE.', 'Procedimientos almacenados: Creación, sintaxis y ejecución.', 'Parámetros en procedimientos (IN, OUT, INOUT).'],
                    activities: ['Implementar un procedimiento que inserte datos.', 'Crear un procedimiento que use un cursor para procesar un conjunto de resultados.'],
                    materials: 'Ejercicios prácticos con SQL.',
                    presentation: [
                        {
                            title: 'El Ciclo de un Cursor Explícito',
                            content: `
### ¿Qué es un Cursor?
Un **cursor** es un área de memoria que Oracle utiliza para procesar una sentencia SQL. Cuando una consulta retorna más de una fila, usamos un **cursor explícito** para procesar cada fila de manera individual.

**Palabras clave en este contexto:**
* **<span class="plsql-keyword">CURSOR</span>**: Declara un cursor explícito.
* **<span class="plsql-keyword">IS</span>**: Usado en la declaración del cursor.
* **<span class="plsql-keyword">OPEN</span>**: Abre el cursor para ejecutar la consulta.
* **<span class="plsql-keyword">FETCH</span>**: Recupera una fila del cursor.
* **<span class="plsql-keyword">INTO</span>**: Asigna los valores de la fila a variables.
* **<span class="plsql-keyword">CLOSE</span>**: Cierra el cursor.
* **<span class="plsql-keyword">%NOTFOUND</span>**: Atributo de cursor que retorna <span class="plsql-keyword">TRUE</span> si la última <span class="plsql-keyword">FETCH</span> no retornó una fila.
`
                        },
                        {
                            title: 'Ejemplo de Cursor Explícito',
                            content: `
\`\`\`sql
DECLARE
  -- 1. Declaración del cursor
  CURSOR c_empleados IS
    SELECT nombre, salario FROM empleados WHERE departamento_id = 20;

  -- 2. Variables para almacenar los datos de cada fila
  v_nombre empleados.nombre%TYPE;
  v_salario empleados.salario%TYPE;
BEGIN
  -- 3. Abrir el cursor
  OPEN c_empleados;

  -- Bucle para procesar cada fila
  LOOP
    -- 4. Leer la fila actual y asignarla a las variables
    FETCH c_empleados INTO v_nombre, v_salario;

    -- Salir del bucle si no hay más filas
    EXIT WHEN c_empleados%NOTFOUND;

    DBMS_OUTPUT.PUT_LINE('Empleado: ' || v_nombre || ', Salario: ' || v_salario);
  END LOOP;

  -- 5. Cerrar el cursor
  CLOSE c_empleados;
END;
/
\`\`\`
**Salida esperada:**
(Asumiendo que hay 3 empleados en el departamento 20)
\`\`\`
Empleado: Juan Pérez, Salario: 65000
Empleado: Maria García, Salario: 72000
Empleado: Pedro López, Salario: 68000
\`\`\`
`
                        },
                        {
                            title: 'Procedimientos Almacenados',
                            content: `
### Subprogramas Reutilizables
Un **procedimiento almacenado** es un bloque de código PL/SQL que se guarda en la base de datos y puede ser llamado múltiples veces desde diferentes aplicaciones. Su propósito es ejecutar una acción específica.

**Palabras clave en este contexto:**
* **<span class="plsql-keyword">CREATE</span>**: Crea un objeto en la base de datos.
* **<span class="plsql-keyword">OR REPLACE</span>**: Reemplaza el objeto si ya existe.
* **<span class="plsql-keyword">PROCEDURE</span>**: Define que se va a crear un procedimiento.
* **<span class="plsql-keyword">AS</span>**: Indica el inicio del bloque de código.
* **<span class="plsql-keyword">IN</span>**: Parámetro de entrada.
* **<span class="plsql-keyword">OUT</span>**: Parámetro de salida.
* **<span class="plsql-keyword">INOUT</span>**: Parámetro de entrada y salida.
`
                        },
                        {
                            title: 'Parámetros y un Ejemplo Práctico',
                            content: `
Los parámetros se usan para pasar datos al procedimiento o para que este retorne valores.

**Ejemplo de procedimiento que aumenta el salario:**
\`\`\`sql
CREATE OR REPLACE PROCEDURE aumentar_salario (
  p_empleado_id IN NUMBER,
  p_porcentaje IN NUMBER
) AS
BEGIN
  UPDATE empleados
  SET salario = salario * (1 + p_porcentaje / 100)
  WHERE empleado_id = p_empleado_id;

  COMMIT;

  DBMS_OUTPUT.PUT_LINE('Salario actualizado para el empleado ' || p_empleado_id);
EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    RAISE;
END;
/
-- Ejecutar el procedimiento para aumentar 10% el salario del empleado 101
BEGIN
  aumentar_salario(101, 10);
END;
/
\`\`\`
**Salida esperada:**
\`\`\`
Salario actualizado para el empleado 101
\`\`\`
`
                        }
                    ]
                },
                {
                    week: 4, module: 3, title: 'Diseño del Proyecto Final',
                    contents: ['Definición de requerimientos y alcance del proyecto.', 'Modelado de la base de datos y diseño del esquema.', 'Creación de un plan de implementación.'],
                    activities: ['Elaborar la documentación de diseño del proyecto.'],
                    materials: 'Guía de proyectos.',
                    presentation: [
                        {
                            title: 'Fase de Diseño del Proyecto',
                            content: `
### De la Idea a la Estructura
La fase de diseño es la más importante. Aquí defines qué hará tu proyecto y cómo se organizarán sus datos.

* **Requerimientos y Alcance:** Define las funcionalidades que tu aplicación debe tener (ej. "registrar usuarios", "gestionar inventario"). El alcance establece los límites del proyecto: qué se incluye y qué no.
* **Modelado de Datos:** Creas un **Modelo Entidad-Relación (MER)** para visualizar cómo se conectan las tablas.
`
                        },
                        {
                            title: 'Del MER al Esquema Lógico',
                            content: `
El modelo lógico es la traducción de tu MER a un esquema de base de datos relacional.
\`\`\`sql
-- Ejemplo de un diseño de esquema para un sistema de pedidos
CREATE TABLE clientes (
  cliente_id    NUMBER(10) PRIMARY KEY,
  nombre        VARCHAR2(100) NOT NULL,
  email         VARCHAR2(100) UNIQUE
);

-- Se crea una secuencia para generar el ID automáticamente
CREATE SEQUENCE seq_clientes START WITH 1 INCREMENT BY 1;

CREATE TABLE pedidos (
  pedido_id     NUMBER(10) PRIMARY KEY,
  cliente_id    NUMBER(10),
  fecha_pedido  DATE DEFAULT SYSDATE,
  estado        VARCHAR2(20) DEFAULT 'PENDIENTE',

  -- Restricción de llave foránea
  CONSTRAINT fk_cliente_pedido FOREIGN KEY (cliente_id) REFERENCES clientes(cliente_id)
);

-- Se crea una secuencia para la tabla de pedidos
CREATE SEQUENCE seq_pedidos START WITH 1 INCREMENT BY 1;
\`\`\`
`
                        },
                        {
                            title: 'Plan de Implementación',
                            content: `
El plan de implementación es tu hoja de ruta. Divide el trabajo en fases para un desarrollo ordenado.

1.  **Diseño:** Completar el MER y el esquema lógico.
2.  **Implementación DDL:** Crear las tablas, índices y secuencias.
3.  **Desarrollo PL/SQL:** Escribir los procedimientos, funciones, paquetes y triggers.
4.  **Pruebas:** Verificar que cada componente funcione correctamente.
5.  **Despliegue:** Poner la aplicación en producción.
`
                        },
                        {
                            title: 'Estructura de la Primera Entrega',
                            content: `
Para la primera entrega, debes presentar:
* Un documento con el **diseño detallado de tu base de datos**.
* Los **scripts DDL** para crear las tablas, secuencias e índices.
* Una **demostración** de algunos componentes básicos de PL/SQL que interactúen con tus tablas.
<a href="https://wilmer155.github.io/Cursos/PL_SQL/Proyecto%20Gestion%20Banco%20PLSQL.pdf" download="Proyecto_Gestion_Banco_PLSQL.pdf" class="boton-descarga">
  Descargar Proyecto
</a>
`
                        }
                    ]
                },
                {
                    week: 5, module: 1, title: 'Funciones y Paquetes',
                    contents: ['Funciones: Creación de funciones para retornar un solo valor. Diferencias entre funciones y procedimientos.', 'Paquetes: Ventajas de usar paquetes.', 'Estructura de un paquete: PACKAGE SPECIFICATION y PACKAGE BODY.', 'Variables y cursores públicos y privados dentro de un paquete.'],
                    activities: ['Escribir una función para calcular un valor.', 'Crear un paquete que agrupe un procedimiento y una función relacionados.'],
                    materials: 'Taller práctico.',
                    presentation: [
                        {
                            title: 'Funciones vs. Procedimientos',
                            content: `
### Funciones en PL/SQL
* **Propósito:** Calcular y retornar un solo valor.
* **Sintaxis:** Usan la cláusula <span class="plsql-keyword">RETURN</span>.
* **Uso:** Pueden ser llamadas desde sentencias SQL.

**Palabras clave en este contexto:**
* **<span class="plsql-keyword">FUNCTION</span>**: Define una función.
* **<span class="plsql-keyword">RETURN</span>**: Usado para especificar el tipo de dato que retorna la función y para devolver un valor.

**Ejemplo de función:**
\`\`\`sql
CREATE OR REPLACE FUNCTION calcular_impuesto (p_salario IN NUMBER)
RETURN NUMBER IS
  v_impuesto NUMBER;
BEGIN
  v_impuesto := p_salario * 0.15;
  RETURN v_impuesto;
END;
/
-- Llamada a la función desde una consulta SQL
SELECT calcular_impuesto(60000) FROM DUAL;
\`\`\`
**Salida esperada:**
\`\`\`
CALCULAR_IMPUESTO(60000)
------------------------
9000
\`\`\`
`
                        },
                        {
                            title: 'Paquetes PL/SQL',
                            content: `
### ¿Qué son los Paquetes?
Un paquete es un contenedor que agrupa lógicamente procedimientos, funciones, variables y otros elementos relacionados en una sola unidad.

### Palabras clave en este contexto:
* **<span class="plsql-keyword">PACKAGE</span>**: Define la especificación del paquete (la interfaz pública).
* **<span class="plsql-keyword">IS</span>**: Usado en la especificación del paquete.
* **<span class="plsql-keyword">END</span>**: Marca el final de la especificación o del cuerpo del paquete.
* **<span class="plsql-keyword">PACKAGE BODY</span>**: Define la implementación del paquete.
`
                        },
                        {
                            title: 'Estructura de un Paquete',
                            content: `
Un paquete tiene dos partes:
1.  **Specification (<span class="plsql-keyword">PACKAGE</span>):** La interfaz pública. Declara los elementos que pueden ser accedidos desde fuera del paquete.
2.  **Body (<span class="plsql-keyword">PACKAGE BODY</span>):** La implementación privada. Contiene el código de los subprogramas declarados en la especificación.

\`\`\`sql
-- 1. Paquete de ESPECIFICACIÓN: define la interfaz
CREATE OR REPLACE PACKAGE gestion_productos IS
  PROCEDURE insertar_producto(p_nombre VARCHAR2, p_precio NUMBER);
  FUNCTION obtener_stock(p_producto_id NUMBER) RETURN NUMBER;
END gestion_productos;
/
\`\`\`
`
                        },
                        {
                            title: 'Body de un Paquete (Implementación)',
                            content: `
El <span class="plsql-keyword">PACKAGE BODY</span> implementa la lógica definida en la especificación.
\`\`\`sql
-- 2. Paquete de IMPLEMENTACIÓN: define la lógica
CREATE OR REPLACE PACKAGE BODY gestion_productos IS

  -- Procedimiento público
  PROCEDURE insertar_producto(p_nombre VARCHAR2, p_precio NUMBER) IS
  BEGIN
    INSERT INTO productos (nombre, precio) VALUES (p_nombre, p_precio);
    COMMIT;
  END insertar_producto;

  -- Función pública
  FUNCTION obtener_stock(p_producto_id NUMBER) RETURN NUMBER IS
    v_stock NUMBER;
  BEGIN
    SELECT stock INTO v_stock FROM productos WHERE producto_id = p_producto_id;
    RETURN v_stock;
  END obtener_stock;

END gestion_productos;
/
\`\`\`
`
                        }
                    ]
                },
                {
                    week: 6, module: 1, title: 'Triggers',
                    contents: ['Concepto de Trigger: Definición, propósito y tipos (DML, DDL, de base de datos).', 'Creación de triggers BEFORE y AFTER.', 'Uso de las cláusulas :NEW y :OLD.', 'Aplicación práctica: Implementar un sistema de auditoría básica con triggers.'],
                    activities: ['Crear un trigger que registre los cambios en una tabla.', 'Crear un trigger que asigne automáticamente un ID usando una secuencia.'],
                    materials: 'Ejemplo aplicado de auditoría.',
                    presentation: [
                        {
                            title: 'Introducción a los Triggers',
                            content: `
### ¿Qué es un Trigger?
Un **trigger** es un bloque de código PL/SQL que se ejecuta automáticamente en respuesta a un evento en la base de datos. Son muy útiles para implementar la lógica de negocio y la auditoría.

**Palabras clave en este contexto:**
* **<span class="plsql-keyword">CREATE TRIGGER</span>**: Comienza la definición de un trigger.
* **<span class="plsql-keyword">BEFORE</span>**: El trigger se dispara antes de la operación.
* **<span class="plsql-keyword">AFTER</span>**: El trigger se dispara después de la operación.
* **<span class="plsql-keyword">ON</span>**: Especifica la tabla sobre la cual el trigger actúa.
* **<span class="plsql-keyword">FOR EACH ROW</span>**: Indica que el trigger se ejecuta para cada fila afectada por la operación.
* **<span class="plsql-keyword">:NEW</span>**: Seudoregistro que contiene los valores de la fila después del cambio.
* **<span class="plsql-keyword">:OLD</span>**: Seudoregistro que contiene los valores de la fila antes del cambio.
`
                        },
                        {
                            title: 'El uso de `:NEW` y `:OLD`',
                            content: `
Dentro de un trigger, puedes acceder a los valores de las filas afectadas.
* **<span class="plsql-keyword">:OLD</span>**: Representa los valores de la fila **antes** del cambio (disponible en <span class="plsql-keyword">UPDATE</span> y <span class="plsql-keyword">DELETE</span>).
* **<span class="plsql-keyword">:NEW</span>**: Representa los valores de la fila **después** del cambio (disponible en <span class="plsql-keyword">INSERT</span> y <span class="plsql-keyword">UPDATE</span>).

**Ejemplo:** <span class="plsql-keyword">SELECT :OLD.salario FROM DUAL;</span> o <span class="plsql-keyword">IF :NEW.salario < :OLD.salario THEN...</span>.
`
                        },
                        {
                            title: 'Trigger de Auditoría',
                            content: `
Este es un ejemplo clásico de un trigger que registra los cambios en la tabla <span class="plsql-keyword">empleados</span>.
\`\`\`sql
-- Se crea una tabla para guardar el historial de cambios
CREATE TABLE empleados_auditoria (
  auditoria_id   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  empleado_id    NUMBER,
  accion         VARCHAR2(10), -- INSERT, UPDATE, DELETE
  fecha          TIMESTAMP,
  salario_antiguo NUMBER,
  salario_nuevo   NUMBER
);

-- Se crea el trigger para registrar cambios en el salario
CREATE OR REPLACE TRIGGER trg_auditar_salario
AFTER UPDATE OF salario ON empleados
FOR EACH ROW
BEGIN
  INSERT INTO empleados_auditoria (empleado_id, accion, fecha, salario_antiguo, salario_nuevo)
  VALUES (:OLD.empleado_id, 'UPDATE', SYSTIMESTAMP, :OLD.salario, :NEW.salario);
END;
/
\`\`\`
`
                        },
                        {
                            title: 'Trigger para Asignar ID con Secuencia',
                            content: `
Un uso muy común de los triggers es asignar un valor a una clave primaria usando una secuencia **antes** de que el registro se inserte.

**Palabras clave en este contexto:**
* **<span class="plsql-keyword">BEFORE INSERT</span>**: El trigger se dispara antes de la inserción de cada fila.

\`\`\`sql
-- Ejemplo: Tabla de productos con un ID que queremos asignar automáticamente
CREATE TABLE productos (
    producto_id   NUMBER(10) PRIMARY KEY,
    nombre        VARCHAR2(100)
);

-- Secuencia para generar los IDs
CREATE SEQUENCE seq_productos START WITH 1 INCREMENT BY 1;

-- Trigger que se dispara antes de cada INSERT
CREATE OR REPLACE TRIGGER trg_productos_id
BEFORE INSERT ON productos
FOR EACH ROW
BEGIN
    -- Si el ID no ha sido proporcionado, se asigna el siguiente valor de la secuencia
    IF :NEW.producto_id IS NULL THEN
        :NEW.producto_id := seq_productos.NEXTVAL;
    END IF;
END;
/
\`\`\`
`
                        }
                    ]
                },
                {
                    week: 7, module: 1, title: 'Excepciones y Colecciones',
                    contents: ['Manejo de excepciones: Excepciones predefinidas (NO_DATA_FOUND, TOO_MANY_ROWS).', 'Creación de excepciones personalizadas y su manejo.', 'Colecciones en PL/SQL: Tablas asociativas (INDEX BY), arrays (VARRAY), tablas anidadas.', 'Bulk Operations: FORALL y BULK COLLECT para mejorar el rendimiento.'],
                    activities: ['Desarrollar un bloque PL/SQL que maneje excepciones personalizadas.', 'Implementar un script que use BULK COLLECT para insertar datos masivos.'],
                    materials: 'Ejercicios avanzados.',
                    presentation: [
                        {
                            title: 'Manejo de Excepciones',
                            content: `
### Atrapando Errores
La sección <span class="plsql-keyword">EXCEPTION</span> de un bloque PL/SQL te permite manejar errores de ejecución de forma controlada.

**Palabras clave en este contexto:**
* **<span class="plsql-keyword">EXCEPTION</span>**: Comienza la sección de manejo de errores.
* **<span class="plsql-keyword">WHEN</span>**: Especifica la excepción a capturar.
* **<span class="plsql-keyword">NO_DATA_FOUND</span>**: Excepción predefinida cuando no se encuentra una fila.
* **<span class="plsql-keyword">TOO_MANY_ROWS</span>**: Excepción predefinida cuando una consulta retorna más de una fila.
* **<span class="plsql-keyword">OTHERS</span>**: Captura cualquier otra excepción no especificada.
* **<span class="plsql-keyword">RAISE</span>**: Lanza una excepción.

\`\`\`sql
DECLARE
  v_salario empleados.salario%TYPE;
BEGIN
  SELECT salario INTO v_salario
  FROM empleados
  WHERE departamento_id = 99;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('Error: El departamento no existe.');
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error inesperado: ' || SQLERRM);
END;
/
\`\`\`
`
                        },
                        {
                            title: 'Colecciones en PL/SQL',
                            content: `
### Estructuras de Datos Similares a los Arrays
Las colecciones son estructuras de datos en memoria que permiten almacenar múltiples elementos del mismo tipo. Son esenciales para las **operaciones bulk**.

**Palabras clave en este contexto:**
* **<span class="plsql-keyword">TYPE</span>**: Define un tipo de dato, en este caso, una colección.
* **<span class="plsql-keyword">IS TABLE OF</span>**: Define una tabla asociativa.
* **<span class="plsql-keyword">INDEX BY</span>**: Define el tipo de índice de la tabla asociativa.
* **<span class="plsql-keyword">VARRAY</span>**: Define un array de tamaño fijo.
* **<span class="plsql-keyword">NESTED TABLE</span>**: Define un array de tamaño variable.
`
                        },
                        {
                            title: 'Operaciones Bulk para Rendimiento',
                            content: `
### <span class="plsql-keyword">FORALL</span> y <span class="plsql-keyword">BULK COLLECT</span>
Procesar datos fila por fila es lento. Las operaciones **bulk** procesan los datos en bloques, reduciendo el número de viajes entre el motor PL/SQL y el motor SQL.

**Palabras clave en este contexto:**
* **<span class="plsql-keyword">BULK COLLECT</span>**: Usado con <span class="plsql-keyword">SELECT INTO</span> para recuperar múltiples filas en una colección.
* **<span class="plsql-keyword">FORALL</span>**: Aplica una operación DML a todos los elementos de una colección en una sola operación.

\`\`\`sql
DECLARE
  TYPE t_empleado_ids IS TABLE OF empleados.empleado_id%TYPE;
  v_empleado_ids t_empleado_ids;
BEGIN
  -- BULK COLLECT: Carga todos los IDs de un departamento en una colección
  SELECT empleado_id
  BULK COLLECT INTO v_empleado_ids
  FROM empleados
  WHERE departamento_id = 20;

  -- FORALL: Aplica un aumento de salario a todos los IDs en la colección en una sola operación
  FORALL i IN v_empleado_ids.FIRST..v_empleado_ids.LAST
    UPDATE empleados
    SET salario = salario * 1.05
    WHERE empleado_id = v_empleado_ids(i);

  COMMIT;

  DBMS_OUTPUT.PUT_LINE(v_empleado_ids.COUNT || ' empleados actualizados.');
END;
/
\`\`\`
`
                        }
                    ]
                },
                {
                    week: 8, module: 1, title: 'SQL Dinámico y Seguridad de PL/SQL',
                    contents: ['Uso del paquete DBMS_SQL y la sentencia EXECUTE IMMEDIATE.', 'Inyección de SQL en PL/SQL y cómo prevenirla.', 'Seguridad en el código PL/SQL: roles, privilegios y definidores de derechos.'],
                    activities: ['Crear un procedimiento que ejecute SQL dinámico de forma segura.', 'Analizar y corregir vulnerabilidades en un código de ejemplo.'],
                    materials: 'Documentación de Oracle sobre seguridad.',
                    presentation: [
                        {
                            title: 'SQL Dinámico: Construir Sentencias en Tiempo Real',
                            content: `
### ¿Qué es el SQL Dinámico?
El **SQL dinámico** te permite construir y ejecutar sentencias SQL completas en tiempo de ejecución. Es útil cuando el nombre de la tabla o la cláusula <span class="plsql-keyword">WHERE</span> no se conocen de antemano.

**Palabras clave en este contexto:**
* **<span class="plsql-keyword">EXECUTE IMMEDIATE</span>**: La forma más simple de ejecutar SQL dinámico.
* **<span class="plsql-keyword">USING</span>**: Asocia una variable a un placeholder en la sentencia SQL dinámica.
`
                        },
                        {
                            title: 'Inyección de SQL: El Peligro Principal',
                            content: `
### Evitando la Inyección de SQL
La **inyección de SQL** es una de las mayores vulnerabilidades. Ocurre cuando se concatenan directamente los datos de entrada del usuario en la sentencia SQL.

**Ejemplo INSEGURO (Vulnerable):**
\`\`\`sql
-- ¡INSEGURO! Concatenación de cadenas
CREATE OR REPLACE PROCEDURE buscar_empleado_inseguro (p_nombre VARCHAR2) AS
  v_sql VARCHAR2(200);
  v_salario NUMBER;
BEGIN
  v_sql := 'SELECT salario FROM empleados WHERE nombre = ''' || p_nombre || '''';
  EXECUTE IMMEDIATE v_sql INTO v_salario;
  DBMS_OUTPUT.PUT_LINE('Salario: ' || v_salario);
END;
/
\`\`\`
**Salida esperada (si p_nombre es 'Juan Pérez'):**
\`\`\`
Salario: 65000
\`\`\`
`
                        },
                        {
                            title: 'SQL Dinámico SEGURO: `EXECUTE IMMEDIATE` con Bind Variables',
                            content: `
La solución es usar **bind variables**. El motor de Oracle separa el código SQL de los datos, previniendo la inyección.

**Ejemplo SEGURO:**
\`\`\`sql
-- ¡SEGURO! Uso de bind variables
CREATE OR REPLACE PROCEDURE buscar_empleado_seguro (p_nombre IN VARCHAR2) AS
  v_salario NUMBER;
BEGIN
  -- El placeholder :1 es una bind variable
  EXECUTE IMMEDIATE 'SELECT salario FROM empleados WHERE nombre = :1'
  INTO v_salario USING p_nombre;

  DBMS_OUTPUT.PUT_LINE('El salario de ' || p_nombre || ' es: ' || v_salario);
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('Empleado ' || p_nombre || ' no encontrado.');
END;
/
\`\`\`
`
                        }
                    ]
                },
                {
                    week: 9, module: 1, title: 'ACLs y Vistas Materializadas',
                    contents: ['Gestión de listas de control de acceso (ACLs) para seguridad de red.', 'Asignación de privilegios a usuarios para acceder a recursos de red.', 'Vistas materializadas: Concepto y casos de uso.', 'Creación, refresco y opciones de las vistas materializadas.'],
                    activities: ['Configurar una ACL para restringir el acceso de un usuario a un sitio web desde la base de datos.', 'Crear una vista materializada para mejorar el rendimiento de una consulta de resumen.'],
                    materials: 'Manual de seguridad de Oracle y documentación de vistas materializadas.',
                    presentation: [
                        {
                            title: 'Seguridad de Red con ACLs',
                            content: `
### Listas de Control de Acceso (ACLs)
Las **ACLs** son un mecanismo de seguridad para controlar qué usuarios pueden acceder a recursos de red externos desde PL/SQL.

**Palabras clave en este contexto:**
* **<span class="plsql-keyword">CREATE ACL</span>**: Crea un archivo de control de acceso.
* **<span class="plsql-keyword">GRANT</span>**: Otorga privilegios a un usuario o rol.
* **<span class="plsql-keyword">REVOKE</span>**: Revoca un privilegio.
`
                        },
                        {
                            title: 'Ejemplo de Configuración de ACL',
                            content: `
Este ejemplo crea una ACL para un usuario y le permite conectarse al dominio <span class="plsql-keyword">www.ejemplo.com</span>.
\`\`\`sql
-- 1. Se crea el archivo ACL y se le otorga el privilegio 'connect' al usuario 'app_user'
BEGIN
  DBMS_NETWORK_ACL_ADMIN.CREATE_ACL (
    acl          => 'app_access_web.xml',
    description  => 'Acceso a sitios web para la aplicación',
    principal    => 'APP_USER',
    is_grant     => TRUE,
    privilege    => 'connect');
END;
/

-- 2. Se asigna el archivo ACL al host
BEGIN
  DBMS_NETWORK_ACL_ADMIN.ASSIGN_ACL (
    acl          => 'app_access_web.xml',
    host         => 'www.ejemplo.com',
    lower_port   => 80,
    upper_port   => 80);
END;
/
\`\`\`
`
                        },
                        {
                            title: 'Vistas Materializadas',
                            content: `
### Rendimiento para Consultas Complejas
Una **vista materializada** es una tabla física que almacena el resultado de una consulta.

**Palabras clave en este contexto:**
* **<span class="plsql-keyword">CREATE MATERIALIZED VIEW</span>**: Crea una vista materializada.
* **<span class="plsql-keyword">BUILD IMMEDIATE</span>**: Llena la vista al momento de su creación.
* **<span class="plsql-keyword">REFRESH FAST ON DEMAND</span>**: Permite un refresco incremental y manual de los datos.
* **<span class="plsql-keyword">REFRESH COMPLETE</span>**: Refresca toda la vista.
`
                        },
                        {
                            title: 'Creación de una Vista Materializada',
                            content: `
\`\`\`sql
-- Se crea una vista materializada para el total de ventas por mes
CREATE MATERIALIZED VIEW mv_ventas_mensuales
BUILD IMMEDIATE
REFRESH FAST ON DEMAND
AS
SELECT
    TO_CHAR(fecha_venta, 'YYYY-MM') AS mes,
    SUM(monto) AS ventas_totales
FROM
    ventas
GROUP BY
    TO_CHAR(fecha_venta, 'YYYY-MM');

-- Para refrescar la vista manualmente
BEGIN
  DBMS_MVIEW.REFRESH('mv_ventas_mensuales');
END;
/
\`\`\`
`
                        }
                    ]
                },
                {
                    week: 10, module: 3, title: 'Desarrollo de proyecto (Primera entrega incremental)',
                    contents: ['Presentación y defensa del Modelo Entidad-Relación (MER).', 'Revisión del código de los componentes de PL/SQL implementados.', 'Demostración de las pruebas y depuración del proyecto.'],
                    activities: ['Realizar la primera entrega incremental del proyecto con el MER y el código inicial.'],
                    materials: 'Formulario de evaluación de primera entrega.',
                    presentation: [
                        {
                            title: 'Presentación del Diseño del Proyecto',
                            content: `
### De la Teoría a la Práctica
En esta primera entrega, demostrarás que tu proyecto tiene una base sólida.

* **Defensa del MER:** Explica tu Modelo Entidad-Relación y justifica las relaciones y las cardinalidades.
* **Script DDL:** Presenta tu script de creación de tablas (<span class="plsql-keyword">CREATE TABLE</span>).
* **Demostración inicial:** Muestra un par de procedimientos o funciones que hayas creado y explica cómo interactúan con las tablas.
`
                        },
                        {
                            title: 'Pruebas y Depuración Básica',
                            content: `
### Cómo Probar tu Código
Una parte crucial de la primera entrega es demostrar que tu código funciona.
* **Pruebas unitarias:** Demuestra que cada procedimiento y función individual funciona como se espera.
* **<span class="plsql-keyword">DBMS_OUTPUT.PUT_LINE</span>**: Usa esta herramienta para imprimir los valores de las variables en puntos clave de tu código y verificar que la lógica se está ejecutando correctamente.
`
                        },
                        {
                            title: 'Ejemplo de Script de Prueba',
                            content: `
\`\`\`sql
DECLARE
  v_salario_actual NUMBER;
  v_salario_esperado NUMBER := 55000;
BEGIN
  -- Se llama al procedimiento para aumentar el salario del empleado 101 en un 10%
  aumentar_salario(101, 10);

  -- Se obtiene el nuevo salario del empleado
  SELECT salario INTO v_salario_actual
  FROM empleados
  WHERE empleado_id = 101;

  -- Se compara el resultado con el valor esperado
  IF v_salario_actual = v_salario_esperado THEN
    DBMS_OUTPUT.PUT_LINE('Prueba exitosa: El salario se actualizó correctamente.');
  ELSE
    DBMS_OUTPUT.PUT_LINE('Prueba fallida: El salario es ' || v_salario_actual || ' pero se esperaba ' || v_salario_esperado);
  END IF;
END;
/
\`\`\`
**Salida esperada (si el salario inicial era 50,000):**
\`\`\`
Prueba exitosa: El salario se actualizó correctamente.
\`\`\`
`
                        }
                    ]
                },
                {
                    week: 11, module: 1, title: 'Job Scheduler',
                    contents: ['Introducción al `DBMS_SCHEDULER`.', 'Creación y gestión de jobs, programas y schedules.', 'Conceptos de ventanas de tiempo y clases de servicio.', 'Ejemplos de automatización de tareas de mantenimiento.'],
                    activities: ['Crear un job simple que ejecute un procedimiento almacenado.', 'Programar un job para que se ejecute en un horario específico.'],
                    materials: 'Documentación oficial de Oracle sobre `DBMS_SCHEDULER`.',
                    presentation: [
                        {
                            title: 'Automatización con `DBMS_SCHEDULER`',
                            content: `
### El Programador de Tareas de Oracle
El paquete **<span class="plsql-keyword">DBMS_SCHEDULER</span>** es la herramienta principal de Oracle para automatizar tareas. Permite programar la ejecución de procedimientos, funciones o sentencias SQL en momentos específicos o a intervalos recurrentes.

**Palabras clave en este contexto:**
* **<span class="plsql-keyword">CREATE_PROGRAM</span>**: Crea un programa que define la acción.
* **<span class="plsql-keyword">CREATE_SCHEDULE</span>**: Crea un horario de ejecución.
* **<span class="plsql-keyword">CREATE_JOB</span>**: Crea una tarea que une un programa y un horario.
* **<span class="plsql-keyword">ENABLED</span>**: Habilita o deshabilita la ejecución del job.
`
                        },
                        {
                            title: 'Ejemplo Completo de un Job',
                            content: `
Este ejemplo crea un trabajo para ejecutar un procedimiento de limpieza de datos cada domingo a la medianoche.
\`\`\`sql
-- 1. Se crea un PROGRAM que ejecuta la lógica de limpieza
BEGIN
  DBMS_SCHEDULER.CREATE_PROGRAM (
    program_name   => 'PRG_LIMPIEZA_SEMANAL',
    program_type   => 'PLSQL_BLOCK',
    program_action => 'BEGIN mi_paquete.limpiar_datos_antiguos; END;',
    enabled        => TRUE
  );
END;
/

-- 2. Se crea un SCHEDULE para definir el horario de ejecución
BEGIN
  DBMS_SCHEDULER.CREATE_SCHEDULE (
    schedule_name   => 'SCH_CADA_DOMINGO_MEDIANOCHE',
    start_date      => TRUNC(SYSDATE) + 1,
    repeat_interval => 'FREQ=WEEKLY; BYDAY=SUN; BYHOUR=0; BYMINUTE=0;',
    enabled         => TRUE
  );
END;
/

-- 3. Se crea un JOB que une el PROGRAM y el SCHEDULE
BEGIN
  DBMS_SCHEDULER.CREATE_JOB (
    job_name        => 'JOB_LIMPIEZA_SEMANAL',
    program_name    => 'PRG_LIMPIEZA_SEMANAL',
    schedule_name   => 'SCH_CADA_DOMINGO_MEDIANOCHE',
    enabled         => TRUE
  );
END;
/
\`\`\`
`
                        }
                    ]
                },
                {
                    week: 12, module: 2, title: 'Arquitectura y Gestión de Usuarios',
                    contents: ['Visión general de la arquitectura: Instance (SGA, Background Processes) y Database (Datafiles, Control files, Redo log files).', 'Estructuras lógicas y físicas de Oracle.', 'Creación y gestión de usuarios, roles y privilegios.'],
                    activities: ['Explorar la arquitectura de una base de datos.', 'Crear un nuevo usuario, asignarle un rol y privilegios.'],
                    materials: 'Oracle DBA Handbook cap. 1-2.',
                    presentation: [
                        {
                            title: 'Arquitectura de una Base de Datos Oracle',
                            content: `
### La relación entre Instancia y Base de Datos
* **Instancia:** Es la memoria (<span class="plsql-keyword">SGA</span>) y los procesos de fondo que administran la base de datos.
* **Base de Datos:** Son los archivos físicos en el disco que almacenan los datos.

Una instancia es la puerta de entrada a la base de datos. Se puede tener múltiples instancias conectadas a una misma base de datos (Oracle RAC).
`
                        },
                        {
                            title: 'Componentes de la Arquitectura',
                            content: `
### Estructuras de Memoria (SGA)
* **Buffer Cache:** Almacena los bloques de datos más usados para un acceso rápido.
* **Shared Pool:** Cachea las sentencias SQL y PL/SQL que ya han sido parseadas.
* **Redo Log Buffer:** Guarda los cambios de la base de datos antes de que se escriban en los archivos físicos.

### Archivos de la Base de Datos
* **Datafiles:** Almacenan los datos de las tablas e índices.
* **Control Files:** Almacenan el estado de la base de datos. Es un archivo crítico.
* **Redo Log Files:** Registran todos los cambios realizados en la base de datos.
`
                        },
                        {
                            title: 'Gestión de Usuarios, Roles y Privilegios',
                            content: `
### Seguridad y Autorización
Como DBA, una de tus principales tareas es gestionar quién puede acceder a la base de datos y qué puede hacer.

**Palabras clave en este contexto:**
* **<span class="plsql-keyword">CREATE USER</span>**: Crea una cuenta de usuario.
* **<span class="plsql-keyword">IDENTIFIED BY</span>**: Define la contraseña del usuario.
* **<span class="plsql-keyword">CREATE ROLE</span>**: Crea un rol para agrupar privilegios.
* **<span class="plsql-keyword">GRANT</span>**: Otorga privilegios o roles.
* **<span class="plsql-keyword">REVOKE</span>**: Revoca privilegios o roles.
`
                        },
                        {
                            title: 'Ejemplo de Gestión de Privilegios',
                            content: `
\`\`\`sql
-- 1. Crear un rol para el personal de ventas
CREATE ROLE rol_ventas;

-- 2. Otorgar privilegios al rol
GRANT CREATE SESSION, SELECT ON empleados TO rol_ventas;
GRANT INSERT, UPDATE ON ventas TO rol_ventas;

-- 3. Crear un usuario y asignarle el rol
CREATE USER juan_ventas IDENTIFIED BY "password_segura";
GRANT rol_ventas TO juan_ventas;

-- 4. Revocar privilegios (si es necesario)
REVOKE INSERT ON ventas FROM rol_ventas;
\`\`\`
`
                        }
                    ]
                },
                {
                    week: 13, module: 3, title: 'Desarrollo de proyecto (Segunda entrega incremental)',
                    contents: ['Codificación de los componentes de PL/SQL (procedimientos, funciones, triggers).', 'Desarrollo de scripts de administración (usuarios, backups, etc.).', 'Pruebas y depuración del proyecto.'],
                    activities: ['Implementar el proyecto final.'],
                    materials: 'Orientación del docente.',
                    presentation: [
                        {
                            title: 'Fase Final de Codificación',
                            content: `
### Integración de Componentes
En esta entrega final de código, debes tener listos la mayoría de los componentes de PL/SQL:
* **Paquetes:** La lógica de negocio más importante debe estar encapsulada en paquetes para una mejor organización.
* **Triggers:** Si tu proyecto necesita auditoría o validaciones automáticas, los triggers deben estar implementados.
* **Funciones y Procedimientos:** Todas las funcionalidades de tu proyecto deben estar operativas y bien probadas.
`
                        },
                        {
                            title: 'Scripts de Administración',
                            content: `
Un proyecto completo no es solo la aplicación, sino también su gestión. Debes incluir scripts para:
* **Creación de usuarios y roles:** Un script para un despliegue rápido.
* **Backups:** Un script de backup lógico o físico.
* **Automatización:** Un job scheduler para tareas repetitivas.
`
                        },
                        {
                            title: 'Pruebas de Integración y Depuración Final',
                            content: `
### Demostración del Sistema Completo
En esta etapa, las pruebas se centran en el sistema completo, no solo en sus partes.
* **Pruebas de integración:** Verifica que todos los componentes (tablas, procedimientos, triggers) trabajan juntos sin errores.
* **Pruebas de casos de uso:** Sigue el flujo de trabajo de tu aplicación y demuestra que se comporta como se espera.
* **Depuración:** Si encuentras errores, utiliza las herramientas del IDE o <span class="plsql-keyword">DBMS_OUTPUT</span> para rastrear el problema.
`
                        }
                    ]
                },
                {
                    week: 14, module: 2, title: 'Optimización de Consultas',
                    contents: ['Plan de ejecución (Explain Plan): Cómo leer e interpretar un plan de ejecución.', 'Índices: Tipos de índices y cuándo usarlos.', 'Estadísticas de la base de datos: DBMS_STATS.', 'Hints de optimización.'],
                    activities: ['Analizar el plan de ejecución de una consulta lenta.', 'Crear un índice para mejorar el rendimiento de la consulta.'],
                    materials: 'Práctica de optimización.',
                    presentation: [
                        {
                            title: 'El Plan de Ejecución',
                            content: `
### ¿Cómo funciona una consulta?
El **plan de ejecución** es el camino que el optimizador de Oracle elige para obtener los datos de una consulta.

**Palabras clave en este contexto:**
* **<span class="plsql-keyword">EXPLAIN PLAN FOR</span>**: Genera el plan de ejecución de una consulta.
`
                        },
                        {
                            title: 'Análisis de un Plan de Ejecución',
                            content: `
Un plan de ejecución te muestra una serie de operaciones. Las más comunes son:
* **<span class="plsql-keyword">TABLE ACCESS FULL</span>:** Se lee toda la tabla. Es lento en tablas grandes.
* **<span class="plsql-keyword">INDEX UNIQUE SCAN</span>:** Se lee el índice para encontrar una fila única de forma muy rápida.
* **<span class="plsql-keyword">INDEX RANGE SCAN</span>:** Se lee un rango de valores del índice.

El objetivo es cambiar las operaciones costosas (como el <span class="plsql-keyword">TABLE ACCESS FULL</span>) por operaciones más eficientes (como los <span class="plsql-keyword">INDEX SCAN</span>).
`
                        },
                        {
                            title: 'Índices: Acelerando las Consultas',
                            content: `
### ¿Qué es un Índice?
Un **índice** es una estructura de datos que acelera la búsqueda de filas en una tabla.

**Palabras clave en este contexto:**
* **<span class="plsql-keyword">CREATE INDEX</span>**: Crea un índice.
* **<span class="plsql-keyword">ON</span>**: Especifica la tabla y columna sobre las que se crea el índice.

**Ejemplo de Creación de un Índice:**
\`\`\`sql
-- Para mejorar el rendimiento, se crea un índice en la columna 'cliente_id'
CREATE INDEX idx_pedidos_cliente ON pedidos(cliente_id);
\`\`\`
`
                        }
                    ]
                },
                {
                    week: 15, module: 2, title: 'Gestión de Almacenamiento y Tabespaces',
                    contents: ['Tablespaces: Creación, gestión y dimensionamiento.', 'Datafiles: Cómo funcionan y su relación con los tablespaces.', 'Diccionario de datos de Oracle: Vistas importantes como DBA_TABLESPACES, DBA_DATA_FILES.'],
                    activities: ['Crear un nuevo tablespace y un datafile.', 'Mover un objeto de base de datos a un nuevo tablespace.'],
                    materials: 'Ejercicios guiados.',
                    presentation: [
                        {
                            title: 'Tablespaces y Datafiles',
                            content: `
### Estructura de Almacenamiento
* **Tablespace:** Es una unidad de almacenamiento **lógica**. Agrupa objetos de la base de datos (tablas, índices, etc.).
* **Datafile:** Es un archivo **físico** en el disco. Cada tablespace consta de uno o más datafiles.

**Palabras clave en este contexto:**
* **<span class="plsql-keyword">CREATE TABLESPACE</span>**: Crea un tablespace.
* **<span class="plsql-keyword">DATAFILE</span>**: Especifica el archivo físico del tablespace.
* **<span class="plsql-keyword">AUTOEXTEND ON</span>**: Permite que el datafile crezca automáticamente.
`
                        },
                        {
                            title: 'Creación de un Tablespace',
                            content: `
\`\`\`sql
-- Se crea un tablespace con un datafile que crece automáticamente
CREATE TABLESPACE datos_proyecto
DATAFILE '/u01/app/oracle/oradata/proyecto/proyecto_data01.dbf'
SIZE 100M
AUTOEXTEND ON NEXT 10M MAXSIZE 1G;
\`\`\`
`
                        },
                        {
                            title: 'Monitoreo con el Diccionario de Datos',
                            content: `
El **diccionario de datos** contiene metadatos sobre la base de datos. Es la mejor manera de monitorear el uso del almacenamiento.

\`\`\`sql
-- Se obtiene el espacio total y libre de los tablespaces
SELECT
    t.tablespace_name,
    ROUND(SUM(t.bytes)/1024/1024) AS "Total MB",
    ROUND(SUM(f.bytes)/1024/1024) AS "Libre MB",
    ROUND((SUM(f.bytes)/SUM(t.bytes))*100) AS "% Libre"
FROM
    dba_data_files t,
    dba_free_space f
WHERE
    t.tablespace_name = f.tablespace_name(+)
GROUP BY
    t.tablespace_name;
\`\`\`
`
                        }
                    ]
                },
                {
                    week: 16, module: 3, title: 'Presentación de proyecto final',
                    contents: ['Presentación final de los proyectos integradores.', 'Evaluación y retroalimentación.', 'Cierre del curso y entrega final de calificaciones.'],
                    activities: ['Presentar el proyecto a la clase.'],
                    materials: 'Formulario de evaluación.',
                    presentation: [
                        {
                            title: '¡El Día de la Presentación!',
                            content: `
### El Momento de la Verdad
La presentación final es tu oportunidad para demostrar todo lo que has aprendido. Prepárate para una demostración fluida y para responder preguntas sobre tu diseño, código y decisiones de administración.

**Puntos clave:**
* **Visión General:** Explica el problema que resuelves y el valor de tu proyecto.
* **Diseño:** Muestra tu esquema de base de datos.
* **Demo:** Demuestra las funcionalidades más importantes de la aplicación.
* **Aspectos Técnicos:** Explica los procedimientos, funciones y triggers clave de tu código.
`
                        },
                        {
                            title: 'Criterios de Evaluación y Retroalimentación',
                            content: `
### ¿Cómo serás evaluado?
El proyecto se evalúa en base a la **funcionalidad**, la **calidad del código**, la **robustez del diseño de la base de datos** y la **claridad de tu presentación**.

Esta es una oportunidad para recibir retroalimentación valiosa que te ayudará a mejorar tus habilidades como desarrollador y administrador de bases de datos.
`
                        }
                    ]
                }
            ],
            bibliography: {
                books: [
                    { title: 'Oracle PL/SQL Programming', author: 'Steven Feuerstein', publisher: 'O\'Reilly (libro de cabecera para PL/SQL).' },
                    { title: 'Oracle Database 12c DBA Handbook', author: 'Bob Bryla y Kevin Loney', publisher: 'McGraw-Hill (excelente para administración).' },
                    { title: 'Oracle Backup & Recovery', author: 'Robert G. Freeman', publisher: 'Oracle Press (especializado en copias de seguridad).' },
                    { title: 'Expert Oracle Database Architecture', author: 'Tom Kyte', publisher: 'Apress (para un nivel más avanzado).' }
                ],
                online: [
                    { title: 'Documentación oficial de Oracle', url: 'https://docs.oracle.com/en/database/' },
                    { title: 'Oracle Live SQL', url: 'https://livesql.oracle.com', description: 'para practicar online sin instalación' },
                    { title: 'Ask Tom', url: 'https://asktom.oracle.com', description: 'sitio de preguntas y respuestas de Oracle' },
                    { title: 'Oracle Learning Library', url: 'https://developer.oracle.com/learning/', description: 'tutoriales y laboratorios online' }
                ]
            }
        };

        // Variables globales para la presentación
        let currentPresentationData = null;
        let currentSlideIndex = 0;

        const showPresentation = (weekData) => {
            const modal = document.getElementById('presentationModal');
            currentPresentationData = weekData.presentation;
            currentSlideIndex = 0;

            modal.style.display = 'flex';
            renderSlide();
        };

        const renderSlide = () => {
            const presentationTitle = document.getElementById('presentationTitle');
            const slideContent = document.getElementById('slideContent');
            const slideCounter = document.getElementById('slideCounter');
            const prevButton = document.getElementById('prevSlide');
            const nextButton = document.getElementById('nextSlide');

            const slide = currentPresentationData[currentSlideIndex];

            presentationTitle.textContent = slide.title;
            // Usar marcado para renderizar el contenido de markdown
            const htmlContent = marked.parse(slide.content);
            slideContent.innerHTML = htmlContent;
            slideCounter.textContent = `Diapositiva ${currentSlideIndex + 1} de ${currentPresentationData.length}`;

            // Actualizar el estado de los botones de navegación
            prevButton.disabled = currentSlideIndex === 0;
            nextButton.disabled = currentSlideIndex === currentPresentationData.length - 1;

            // Ajuste automático de scroll en caso de que el contenido sea muy largo
            slideContent.scrollTop = 0;
        };

        const goToNextSlide = () => {
            if (currentSlideIndex < currentPresentationData.length - 1) {
                currentSlideIndex++;
                renderSlide();
            }
        };

        const goToPrevSlide = () => {
            if (currentSlideIndex > 0) {
                currentSlideIndex--;
                renderSlide();
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
            const navItems = document.querySelectorAll('.nav-item');
            const weeksGrid = document.getElementById('weeks-grid');
            const bibliographyContent = document.getElementById('bibliography-content');
            const contentIntro = document.getElementById('content-intro');
            const introTexts = {
                all: "Bienvenido al plan de estudios. Utiliza las pestañas de navegación para filtrar los temas por módulo o para consultar la bibliografía recomendada. Haz clic en cualquier tarjeta de semana para ver una presentación detallada de su contenido.",
                1: "Este módulo se enfoca en los fundamentos de la programación con PL/SQL, el lenguaje procedural de Oracle. Aprenderás a crear bloques de código, procedimientos, funciones, triggers y a manejar la lógica de negocio directamente en la base de datos.",
                2: "El segundo módulo te introduce al mundo de la Administración de Bases de Datos (DBA). Cubriremos la arquitectura de Oracle, la gestión de usuarios, el almacenamiento, las estrategias de backup y recuperación, y la optimización de consultas.",
                3: "El módulo final consiste en el desarrollo de un proyecto integrador donde aplicarás todos los conocimientos de PL/SQL y administración adquiridos durante el curso para resolver un caso práctico.",
                bibliography: "A continuación se presentan los recursos bibliográficos y en línea recomendados que servirán de apoyo fundamental a lo largo del curso. Se aconseja su consulta regular para profundizar en los temas tratados en clase."
            };

            const renderWeeks = (filter) => {
                weeksGrid.innerHTML = '';
                bibliographyContent.classList.add('hidden');
                weeksGrid.classList.remove('hidden');

                const filteredWeeks = courseData.weeks.filter(week => filter === 'all' || week.module == filter);

                filteredWeeks.forEach(week => {
                    const card = document.createElement('div');
                    card.className = `bg-white rounded-xl shadow-lg border-t-4 border-${week.module === 1 ? 'blue-500' : week.module === 2 ? 'emerald-500' : 'orange-500'} overflow-hidden transform hover:-translate-y-1 transition-transform duration-300 flex flex-col cursor-pointer`;
                    card.innerHTML = `
                        <div class="p-6">
                            <div class="tracking-wide text-sm text-gray-500 font-bold">SEMANA ${week.week} - MÓDULO ${week.module}</div>
                            <h3 class="block mt-1 text-lg leading-tight font-semibold text-gray-800">${week.title}</h3>
                        </div>
                        <div class="p-6 pt-0 flex-grow">
                            <h4 class="font-bold text-gray-700 mb-2">Contenidos:</h4>
                            <ul class="list-disc list-inside text-gray-600 space-y-1 text-sm">
                                ${week.contents.map(item => `<li>${item}</li>`).join('')}
                            </ul>
                            <h4 class="font-bold text-gray-700 mt-4 mb-2">Actividades:</h4>
                            <ul class="list-disc list-inside text-gray-600 space-y-1 text-sm">
                                ${week.activities.map(item => `<li>${item}</li>`).join('')}
                            </ul>
                        </div>
                        <div class="p-6 pt-2 bg-gray-50">
                            <h4 class="font-bold text-gray-700 mb-2">Material de apoyo:</h4>
                            <p class="text-gray-600 text-sm">${week.materials}</p>
                        </div>
                    `;
                    card.addEventListener('click', () => showPresentation(week));
                    weeksGrid.appendChild(card);
                });
            };

            const renderBibliography = () => {
                weeksGrid.classList.add('hidden');
                bibliographyContent.classList.remove('hidden');
                const bib = courseData.bibliography;
                bibliographyContent.innerHTML = `
                    <div class="bg-white rounded-xl shadow-lg p-6 md:p-8 max-w-4xl mx-auto">
                        <h3 class="text-2xl font-bold text-blue-800 mb-6">Libros Recomendados</h3>
                        <div class="space-y-4">
                            ${bib.books.map(book => `
                                <div>
                                    <p class="font-semibold text-gray-800">${book.title}</p>
                                    <p class="text-gray-600 text-sm">Por ${book.author} - ${book.publisher}</p>
                                </div>
                            `).join('')}
                        </div>
                        <h3 class="text-2xl font-bold text-blue-800 mt-8 mb-6">Recursos Online</h3>
                        <div class="space-y-4">
                             ${bib.online.map(link => `
                                <div>
                                    <a href="${link.url}" target="_blank" rel="noopener noreferrer" class="font-semibold text-blue-700 hover:underline">${link.title}</a>
                                    <p class="text-gray-600 text-sm">${link.description || ''}</p>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            };

            navItems.forEach(item => {
                item.addEventListener('click', () => {
                    const filter = item.dataset.filter;

                    navItems.forEach(nav => nav.classList.remove('nav-active'));
                    item.classList.add('nav-active');

                    contentIntro.textContent = introTexts[filter];

                    if (filter === 'bibliography') {
                        renderBibliography();
                    } else {
                        renderWeeks(filter);
                    }
                });
            });

            const renderChart = () => {
                const ctx = document.getElementById('courseStructureChart').getContext('2d');
                new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['Módulo 1: Fundamentos de PL/SQL', 'Módulo 2: Administración (DBA)', 'Módulo 3: Proyecto Final'],
                        datasets: [{
                            label: 'Semanas por Módulo',
                            data: [9, 3, 4],
                            backgroundColor: [
                                'rgba(59, 130, 246, 0.6)', /* blue-500 */
                                'rgba(16, 185, 129, 0.6)', /* emerald-500 */
                                'rgba(255, 152, 0, 0.6)'  /* orange-500 */
                            ],
                            borderColor: [
                                'rgba(59, 130, 246, 1)',
                                'rgba(16, 185, 129, 1)',
                                'rgba(255, 152, 0, 1)'
                            ],
                            borderWidth: 1
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                beginAtZero: true,
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.05)'
                                }
                            },
                             y: {
                                grid: {
                                    display: false
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.x !== null) {
                                            label += `${context.parsed.x} semanas`;
                                        }
                                        return label;
                                    }
                                }
                            }
                        }
                    }
                });
            };

            document.querySelector('.close-button').onclick = function() {
                document.getElementById('presentationModal').style.display = 'none';
                currentPresentationData = null;
                currentSlideIndex = 0;
            }

            document.getElementById('prevSlide').onclick = goToPrevSlide;
            document.getElementById('nextSlide').onclick = goToNextSlide;

            window.onclick = function(event) {
                const modal = document.getElementById('presentationModal');
                if (event.target === modal) {
                    modal.style.display = 'none';
                    currentPresentationData = null;
                    currentSlideIndex = 0;
                }
            }

            // Inicialización al cargar la página
            renderWeeks('all');
            renderChart();
        });

    </script>
</body>
</html>
